// The module 'vscode' contains the VS Code extensibility API
// Import the module and reference it with the alias vscode in your code below
import * as vscode from 'vscode';
import { SqlcIndex } from './sqlc_index';

// This method is called when your extension is activated
// Your extension is activated the very first time the command is executed
export async function activate(context: vscode.ExtensionContext) {

	const outputChannel = vscode.window.createOutputChannel('sqlc');
	context.subscriptions.push(outputChannel);
	outputChannel.appendLine('sqlc extension activated');

	const sqlIndex = new SqlcIndex(outputChannel);
	context.subscriptions.push(sqlIndex);

	await sqlIndex.init();

	outputChannel.appendLine('sqlc index built and watching for changes');

	const goDefProvider = vscode.languages.registerDefinitionProvider({ scheme: 'file', language: 'go' }, {
		provideDefinition(document, position, token) {
			const wordRange = document.getWordRangeAtPosition(position, /[A-Za-z0-9_]+/);
			if (!wordRange) return;
			const name = document.getText(wordRange);
			outputChannel.appendLine(`Looking up definition for: ${name}`);

			const hits = sqlIndex.lookup(name);
			if (!hits || hits.length === 0) {
				outputChannel.appendLine(`No hits found for: ${name}`);
				return;
			}

			// Return LocationLinks; VS Code merges with other providers (gopls)
			const links: vscode.LocationLink[] = hits.map(h => ({
				originSelectionRange: wordRange,
				targetUri: h.uri,
				targetRange: h.range,
				targetSelectionRange: h.range
			}));

			return links;
		}
	});


	context.subscriptions.push(sqlIndex);
	context.subscriptions.push(goDefProvider);
}

// This method is called when your extension is deactivated
export function deactivate() {}


// export async function activate(ctx: vscode.ExtensionContext) {
//   const output = vscode.window.createOutputChannel('sqlc');
//   const index = new SqlcIndex(output);
//   ctx.subscriptions.push(index, output);

//   await index.build();
//   await index.watch();

//   // Definition provider: returns the SQL location(s) if the symbol matches a query name
//   ctx.subscriptions.push(vscode.languages.registerDefinitionProvider({ language: 'go' }, {
//     provideDefinition(doc, pos, token) {
//       const wordRange = doc.getWordRangeAtPosition(pos, /[A-Za-z0-9_]+/);
//       if (!wordRange) return;
//       const name = doc.getText(wordRange);
//       const hits = index.lookup(name);
//       if (!hits || hits.length === 0) return;

//       // Return LocationLinks; VS Code merges with other providers (gopls)
//       const links: vscode.LocationLink[] = hits.map(h => ({
//         originSelectionRange: wordRange,
//         targetUri: h.uri,
//         targetRange: h.range,
//         targetSelectionRange: h.range
//       }));

//       return links;
//     }
//   }));

//   // CodeLens provider over generated methods in .gen.go files
//   ctx.subscriptions.push(vscode.languages.registerCodeLensProvider({ language: 'go' }, new class implements vscode.CodeLensProvider {
//     onDidChangeCodeLenses?: vscode.Event<void> | undefined;
//     async provideCodeLenses(doc: vscode.TextDocument, token: vscode.CancellationToken) {
//       const text = doc.getText();
//       // Only in sqlc-generated files if possible (look for standard header)
//       if (!/Code generated by sqlc\. DO NOT EDIT\./.test(text)) return [];

//       // Find methods: func (q *Queries) <Name>(
//       const lenses: vscode.CodeLens[] = [];
//       const methodRe = /^func\s+\(\s*\w+\s+\*Queries\s*\)\s+([A-Za-z0-9_]+)\s*\(/gm;
//       let m: RegExpExecArray | null;
//       while ((m = methodRe.exec(text)) !== null) {
//         const name = m[1];
//         const hits = index.lookup(name);
//         if (!hits || hits.length === 0) continue;

//         const start = doc.positionAt(m.index);
//         const range = new vscode.Range(start, start);

//         lenses.push(new vscode.CodeLens(range, {
//           title: 'Open SQL query',
//           command: 'sqlc.openQueryAt',
//           arguments: [hits]
//         }));
//       }
//       return lenses;
//     }
//   }));

//   // Command: open (or peek) at SQL query target(s)
//   ctx.subscriptions.push(vscode.commands.registerCommand('sqlc.openQueryAt', async (hits: QueryHit[]) => {
//     if (!hits || hits.length === 0) return;
//     const usePeek = vscode.workspace.getConfiguration('sqlc').get<boolean>('peekInsteadOfGoTo', false);

//     if (usePeek && vscode.window.activeTextEditor) {
//       const editor = vscode.window.activeTextEditor;
//       const pos = editor.selection.active;
//       const locs = hits.map(h => new vscode.Location(h.uri, h.range));
//       await vscode.commands.executeCommand(
//         'editor.action.peekLocations',
//         editor.document.uri,
//         pos,
//         locs,
//         'goto' // or 'peek' â€“ 'goto' shows the peek UI here
//       );
//     } else {
//       // If multiple, quick pick
//       let choice = hits[0];
//       if (hits.length > 1) {
//         const picked = await vscode.window.showQuickPick(
//           hits.map(h => ({
//             label: `${path.basename(h.uri.fsPath)} ${h.command}`,
//             description: vscode.workspace.asRelativePath(h.uri.fsPath),
//             hit: h
//           })),
//           { placeHolder: 'Multiple matching SQL queries found' }
//         );
//         if (picked) choice = picked.hit;
//       }
//       const doc = await vscode.workspace.openTextDocument(choice.uri);
//       const ed = await vscode.window.showTextDocument(doc, { preview: true });
//       ed.revealRange(choice.range, vscode.TextEditorRevealType.InCenter);
//       ed.selection = new vscode.Selection(choice.range.start, choice.range.start);
//     }
//   }));

//   ctx.subscriptions.push(vscode.commands.registerCommand('sqlc.reindex', async () => {
//     await index.build();
//     vscode.window.showInformationMessage('sqlc: reindexed SQL queries.');
//   }));
// }

// export function deactivate() {}